<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Read to Sleep - Text to Speech</title>
    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1f2937;
        }

        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* Modal animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal {
            animation: fadeIn 0.2s ease-out;
        }

        .modal-content {
            animation: slideIn 0.3s ease-out;
        }

        /* Tab styles */
        .tab-btn {
            transition: all 0.2s ease;
        }

        .tab-btn.active {
            color: #0ea5e9;
            border-color: #0ea5e9;
        }

        /* Button hover effects */
        button {
            transition: all 0.2s ease;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Status indicators */
        .status {
            font-size: 1.5rem;
            line-height: 1.5;
            padding: 2rem 1rem;
            height: calc(1.5em * 3); /* Exactly 3 lines height */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        .status.playing {
            color: #0ea5e9;
        }

        .status.error {
            color: #ef4444;
        }

        .status.success {
            color: #10b981;
        }

        .status.warning {
            color: #f59e0b;
        }

        /* Playlist item styles */
        .playlist-item.played {
            opacity: 0.7;
        }

        .playlist-item.played .playlist-title {
            text-decoration: line-through;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .grid.grid-cols-2 {
                grid-template-columns: 1fr;
            }
            
            .flex.flex-wrap.gap-3 > * {
                flex: 1 1 45%;
            }

            .status {
                font-size: 1.5rem;
                padding: 1.5rem 1rem;
                height: calc(1.5em * 3);
            }
        }

        @media (max-width: 480px) {
            .flex.flex-wrap.gap-3 > * {
                flex: 1 1 100%;
            }

            .status {
                font-size: 1.25rem;
                padding: 1.25rem 1rem;
                height: calc(1.5em * 3);
            }
            
            .grid.grid-cols-2 {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <!-- <script src="https://cdn.tailwindcss.com"></script> -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            200: '#bae6fd',
                            300: '#7dd3fc',
                            400: '#38bdf8',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                            800: '#075985',
                            900: '#0c4a6e',
                        },
                        secondary: {
                            50: '#f5f3ff',
                            100: '#ede9fe',
                            200: '#ddd6fe',
                            300: '#c4b5fd',
                            400: '#a78bfa',
                            500: '#8b5cf6',
                            600: '#7c3aed',
                            700: '#6d28d9',
                            800: '#5b21b6',
                            900: '#4c1d95',
                        }
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <header class="text-center mb-12">
            <h1 class="text-4xl md:text-5xl font-bold bg-gradient-to-r from-primary-400 to-secondary-400 bg-clip-text text-transparent">
                Read to Sleep
            </h1>
            <p class="text-gray-400 mt-2">อ่านนิยายจีน..จนกว่าคุณจะหลับ</p>
        </header>

        <main>
            <!-- Text Input Section -->
            <section class="mb-4">
                <div class="bg-gray-800 rounded-xl p-6 shadow-lg">
                    <div class="mb-4">
                        <div class="flex items-center justify-between mb-4">
                            <h2 class="text-xl font-semibold flex items-center gap-2">
                                <i data-feather="file-text" class="w-5 h-5"></i>
                                เนื้อเรื่อง
                            </h2>
                            <div class="flex gap-2">
                                <button id="pasteBtn" class="px-3 py-1.5 bg-gray-800 hover:bg-gray-700 rounded-lg transition-colors text-sm flex items-center gap-1">
                                    <i data-feather="clipboard" class="w-4 h-4"></i>
                                    วาง
                                </button>
                                <button id="clearBtn" class="px-3 py-1.5 bg-gray-800 hover:bg-gray-700 rounded-lg transition-colors text-sm flex items-center gap-1">
                                    <i data-feather="trash-2" class="w-4 h-4"></i>
                                    ล้าง
                                </button>
                            </div>
                        </div>
                        <textarea 
                            id="text" 
                            class="w-full h-64 bg-gray-700 border border-gray-600 rounded-lg p-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent resize-none"
                            placeholder="บทความที่ต้องการให้อ่านออกเสียง..."></textarea>
                    </div>

                    <div class="flex flex-wrap gap-3">
                        <button id="speakBtn" class="flex-1 min-w-[120px] bg-primary-600 hover:bg-primary-700 text-white py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                            <i data-feather="play"></i> อ่าน
                        </button>
                        <button id="stopBtn" class="flex-1 min-w-[120px] bg-red-600 hover:bg-red-700 text-white py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2" disabled>
                            <i data-feather="square"></i> ยกเลิก
                        </button>
                        <button id="previousBtn" class="flex-1 min-w-[120px] bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2" disabled>
                            <i data-feather="skip-back"></i> ก่อนหน้า
                        </button>
                        <button id="nextBtn" class="flex-1 min-w-[120px] bg-gray-700 hover:bg-gray-600 text-white py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2" disabled>
                            <i data-feather="skip-forward"></i> ถัดไป
                        </button>
                    </div>
                </div>
            </section>

            <!-- Action Buttons -->
            <section class="mb-4">
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                    <button id="wordBtn" class="bg-gray-800 hover:bg-gray-700 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                        <i data-feather="edit-3"></i> Custom Word
                    </button>
                    <button id="addToPlaylistMainBtn" class="bg-gray-800 hover:bg-gray-700 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                        <i data-feather="plus-circle"></i> เพิ่ม Playlist
                    </button>
                    <button id="playlistBtn" class="bg-gray-800 hover:bg-gray-700 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                        <i data-feather="list"></i> Playlist
                    </button>
                    <button id="settingBtn" class="bg-gray-800 hover:bg-gray-700 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                        <i data-feather="settings"></i> Setting
                    </button>
                </div>
            </section>

            <!-- AI Section -->
            <section class="mb-4">
                <div class="bg-gray-800 rounded-xl p-6 shadow-lg">
                    <!-- <h2 class="text-xl font-semibold mb-4 text-gray-200">AI Assistant</h2> -->
                    
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <div class="relative">
                            <input 
                                type="password" 
                                id="apiKey" 
                                class="w-full bg-gray-700 border border-gray-600 rounded-lg py-3 px-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent pr-10"
                                placeholder="API Key">
                            <div id="apiStatus" class="absolute right-3 top-1/2 transform -translate-y-1/2 w-3 h-3 rounded-full bg-green-500"></div>
                        </div>
                        
                        <select id="modelSelect" class="bg-gray-700 border border-gray-600 rounded-lg py-3 px-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent">
                            <option value="gemini-2.5-flash">gemini-2.5-flash</option>
                            <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                            <option value="gemini-1.5-flash">gemini-1.5-flash</option>
                            <option value="gemini-1.5-pro">gemini-1.5-pro</option>
                            <option value="gemini-1.0-pro">gemini-1.0-pro</option>
                        </select>
                        
                        <button id="promptBtn" class="bg-gray-700 hover:bg-gray-600 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                            <i data-feather="settings"></i> Prompt
                        </button>
                    </div>
                    
                    <div class="grid gap-4 grid-cols-[repeat(auto-fit,minmax(150px,1fr))]">
                        <button id="aiEditBtn" class="bg-gray-700 hover:bg-gray-600 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                            <i data-feather="edit"></i> AI จัดคำ
                        </button>
                        <button id="aiSummarizeBtn" class="bg-gray-700 hover:bg-gray-600 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                            <i data-feather="file-text"></i> AI สรุป
                        </button>
                        <button id="aiMyStyleBtn" class="bg-gray-700 hover:bg-gray-600 text-gray-200 py-3 px-4 rounded-lg transition duration-200 flex items-center justify-center gap-2">
                            <i data-feather="type"></i> AI สั้น
                        </button>
                    </div>
                </div>
            </section>

            <!-- Progress and Status -->
            <section class="mb-4">
                <div class="bg-gray-800 rounded-xl p-6 shadow-lg">
                    <div class="text-sm text-gray-400 text-center mb-2">
                        <span id="progressText">0/0</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2.5 mb-6">
                        <div id="progressBar" class="bg-primary-500 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                    <div id="status" class="text-center text-gray-300 status">
                        ป้อนข้อความเพื่อเริ่มต้น
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Custom Words Modal -->
    <div id="wordModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-100">Custom Words</h2>
                    <button id="closeWordModal" class="text-gray-400 hover:text-white">
                        <i data-feather="x"></i>
                    </button>
                </div>
                
                <div class="mb-4">
                    <textarea 
                        id="customWords" 
                        class="w-full h-48 bg-gray-700 border border-gray-600 rounded-lg p-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent resize-none"
                        placeholder="ตัวอย่าง:
กรุงเทพฯ;กรุงเทพมหานคร
รพ.;โรงพยาบาล
ดร.;ดอกเตอร์"></textarea>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                    <div class="flex items-center gap-2">
                        <input type="file" id="importFile" accept=".txt" class="hidden">
                        <button id="importBtn" class="bg-gray-700 hover:bg-gray-600 text-gray-200 py-2 px-4 rounded-lg transition duration-200 flex-1">
                            นำเข้าจากไฟล์
                        </button>
                    </div>
                    <div class="flex gap-2">
                        <button id="saveWordsBtn" class="bg-primary-600 hover:bg-primary-700 text-white py-2 px-4 rounded-lg transition duration-200 flex-1">
                            บันทึก
                        </button>
                        <button id="sortWordsBtn" class="bg-secondary-600 hover:bg-secondary-700 text-white py-2 px-4 rounded-lg transition duration-200">
                            Sort
                        </button>
                    </div>
                </div>
                
                <div class="bg-gray-700 rounded-lg p-4">
                    <h3 class="text-lg font-medium text-gray-200 mb-3">ทดสอบเสียง</h3>
                    <div class="flex gap-2">
                        <input 
                            type="text" 
                            id="previewText" 
                            class="flex-1 bg-gray-600 border border-gray-500 rounded-lg py-2 px-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
                            placeholder="พิมพ์ข้อความเพื่อทดสอบเสียง...">
                        <button id="previewBtn" class="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition duration-200">
                            ทดสอบเสียง
                        </button>
                    </div>
                    <!-- <div id="previewStatus" class="mt-3 text-center py-2 text-gray-300">
                        ป้อนข้อความเพื่อทดสอบ
                    </div> -->
                </div>
            </div>
        </div>
    </div>

    <!-- Playlist Modal -->
    <div id="playlistModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-gray-100">Playlist</h2>
                    <button id="closePlaylistModal" class="text-gray-400 hover:text-white">
                        <i data-feather="x"></i>
                    </button>
                </div>
                
                <div class="flex flex-wrap gap-3 mb-6 items-center justify-center">
                    <button id="playAllBtn" class="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition duration-200 flex items-center gap-2">
                        <i data-feather="play"></i> Play All Unplayed
                    </button>
                    <button id="clearAllBtn" class="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg transition duration-200 flex items-center gap-2">
                        <i data-feather="trash-2"></i> Clear All List
                    </button>
                </div>
                
                <div id="playlistItems" class="space-y-3">
                    <div class="text-center py-8 text-gray-400">
                        ไม่มีรายการใน Playlist
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
    <div class="bg-gray-800 rounded-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div class="p-6">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold text-gray-100">ตั้งค่า (Settings)</h2>
            <button id="closeSettingsModal" class="text-gray-400 hover:text-white">
            <i data-feather="x" class="w-5 h-5"></i>
            </button>
        </div>

        <!-- ความเร็วอ่าน -->
        <div class="mb-4">
        <label for="speechSpeed" class="block text-gray-300 mb-2">ความเร็วอ่าน:</label>
        <input type="range" id="speechSpeed" min="0.5" max="2" step="0.05" value="1.35"
                class="w-full bg-gray-700 border border-gray-600 rounded-lg h-2 appearance-none accent-primary-500 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent">
            <div class="flex justify-between text-xs text-gray-400 mt-1">
                <span>0.5×</span>
                <span id="speechSpeedValue">1.35×</span>
                <span>2.0×</span>
            </div>
        </div>

        <!-- จำนวนต่อ chunk -->
        <div class="mb-4">
        <label for="chunkSize" class="block text-gray-300 mb-2">จำนวนต่อ chunk (คำ):</label>
        <input type="number" id="chunkSize" min="1" max="1000" step="1" value="120"
                class="w-full bg-gray-700 border border-gray-600 rounded-lg py-3 px-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent">
        <div class="text-xs text-gray-400 mt-1">กำหนดจำนวนคำต่อครั้งก่อนอ่าน</div>
        </div>

        <div class="flex flex-wrap gap-3 mt-6">
            <button id="saveSettingsBtn" class="flex-1 bg-primary-600 hover:bg-primary-700 text-white py-2 px-4 rounded-lg transition duration-200">
            บันทึก
            </button>
            <button id="resetSettingsBtn" class="flex-1 bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg transition duration-200">
            รีเซ็ตค่า
            </button>
        </div>

        </div>
    </div>
    </div>

    <!-- Prompt Modal -->
    <div id="promptModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50 hidden">
        <div class="bg-gray-800 rounded-xl w-full max-w-2xl max-h-[90vh] overflow-y-auto">
            <div class="p-6">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-gray-100">ปรับแต่ง Prompt</h2>
                    <button id="closePromptModal" class="text-gray-400 hover:text-white">
                        <i data-feather="x"></i>
                    </button>
                </div>
                
                <div class="mb-6">
                    <div class="flex border-b border-gray-700">
                        <button class="tab-btn active py-3 px-6 text-gray-300 hover:text-white border-b-2 border-primary-500" data-tab="edit-tab">
                            AI จัดคำ
                        </button>
                        <button class="tab-btn py-3 px-6 text-gray-300 hover:text-white" data-tab="summarize-tab">
                            AI สรุป
                        </button>
                        <button class="tab-btn py-3 px-6 text-gray-300 hover:text-white" data-tab="mystyle-tab">
                            AI สั้น
                        </button>
                    </div>
                    
                    <div class="mt-4">
                        <div id="edit-tab" class="tab-pane active">
                            <textarea 
                                id="editPrompt" 
                                class="w-full h-48 bg-gray-700 border border-gray-600 rounded-lg p-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent resize-none"></textarea>
                        </div>
                        <div id="summarize-tab" class="tab-pane hidden">
                            <textarea 
                                id="summarizePrompt" 
                                class="w-full h-48 bg-gray-700 border border-gray-600 rounded-lg p-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent resize-none"></textarea>
                        </div>
                        <div id="mystyle-tab" class="tab-pane hidden">
                            <textarea 
                                id="mystylePrompt" 
                                class="w-full h-48 bg-gray-700 border border-gray-600 rounded-lg p-4 text-gray-100 focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent resize-none"></textarea>
                        </div>
                    </div>
                </div>
                
                <div class="flex flex-wrap gap-3">
                    <button id="resetPromptsBtn" class="bg-red-600 hover:bg-red-700 text-white py-2 px-4 rounded-lg transition duration-200 flex-1">
                        ล้าง Prompt
                    </button>
                    <button id="savePromptsBtn" class="bg-primary-600 hover:bg-primary-700 text-white py-2 px-4 rounded-lg transition duration-200 flex-1">
                        บันทึก Prompt
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        function setupTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanes = document.querySelectorAll('.tab-pane');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.getAttribute('data-tab');

                    // Deactivate all tabs and panes
                    tabButtons.forEach(btn => {
                        btn.classList.remove('active');
                        // Assuming inactive tabs have a transparent border or you can set it to the default gray from your CSS
                        btn.style.borderColor = 'transparent'; 
                    });
                    tabPanes.forEach(pane => {
                        pane.classList.remove('active');
                        pane.classList.add('hidden');
                    });

                    // Activate the clicked tab and pane
                    button.classList.add('active');
                    // Using the primary color from your tailwind config
                    button.style.borderColor = '#0ea5e9'; 
                    const activePane = document.getElementById(tabId);
                    if (activePane) {
                        activePane.classList.add('active');
                        activePane.classList.remove('hidden');
                    }
                });
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            const log = (message, ...args) => console.log('[TTS]', message, ...args);
            log('Application initialized.');

            setupTabs();
            
            const textInput = document.getElementById('text');
            const speakBtn = document.getElementById('speakBtn');
            const stopBtn = document.getElementById('stopBtn');
            const previousBtn = document.getElementById('previousBtn');
            const nextBtn = document.getElementById('nextBtn');
            const clearBtn = document.getElementById('clearBtn');
            const pasteBtn = document.getElementById('pasteBtn');
            const addToPlaylistMainBtn = document.getElementById('addToPlaylistMainBtn');
            const wordBtn = document.getElementById('wordBtn');
            const playlistBtn = document.getElementById('playlistBtn');
            const statusDiv = document.getElementById('status');
            const progressBar = document.getElementById('progressBar');
            
            // AI Elements
            const apiKeyInput = document.getElementById('apiKey');
            const modelSelect = document.getElementById('modelSelect');
            const apiStatus = document.getElementById('apiStatus');
            const aiEditBtn = document.getElementById('aiEditBtn');
            const aiSummarizeBtn = document.getElementById('aiSummarizeBtn');
            const aiMyStyleBtn = document.getElementById('aiMyStyleBtn');
            const promptBtn = document.getElementById('promptBtn');
            
            // Modal elements
            const wordModal = document.getElementById('wordModal');
            const playlistModal = document.getElementById('playlistModal');
            const promptModal = document.getElementById('promptModal');
            const closeWordModal = document.getElementById('closeWordModal');
            const closePlaylistModal = document.getElementById('closePlaylistModal');
            const closePromptModal = document.getElementById('closePromptModal');
            const customWordsTextarea = document.getElementById('customWords');
            const saveWordsBtn = document.getElementById('saveWordsBtn');
            const importFileInput = document.getElementById('importFile');
            const importBtn = document.getElementById('importBtn');
            const previewText = document.getElementById('previewText');
            const previewBtn = document.getElementById('previewBtn');
            const previewStatus = document.getElementById('previewStatus');
            const sortWordsBtn = document.getElementById('sortWordsBtn');
            
            // Settings Modal Elements
            const settingBtn = document.getElementById('settingBtn');
            const settingsModal = document.getElementById('settingsModal');
            const closeSettingsModal = document.getElementById('closeSettingsModal');
            const speechSpeed = document.getElementById('speechSpeed');
            const speechSpeedValue = document.getElementById('speechSpeedValue');
            const chunkSize = document.getElementById('chunkSize');
            const saveSettingsBtn = document.getElementById('saveSettingsBtn');
            const resetSettingsBtn = document.getElementById('resetSettingsBtn');

            // Prompt Modal Elements
            const editPromptTextarea = document.getElementById('editPrompt');
            const summarizePromptTextarea = document.getElementById('summarizePrompt');
            const mystylePromptTextarea = document.getElementById('mystylePrompt');
            const savePromptsBtn = document.getElementById('savePromptsBtn');
            const resetPromptsBtn = document.getElementById('resetPromptsBtn');
            
            // Playlist elements
            const playlistItems = document.getElementById('playlistItems');
            const playAllBtn = document.getElementById('playAllBtn');
            const clearAllBtn = document.getElementById('clearAllBtn');
            
            let audioQueue = []; // This will now hold TEXT chunks
            let audioBuffer = new Map(); // Holds pre-fetched Audio objects {index: audio}
            let isPlaying = false;
            let isPaused = false;
            let currentIndex = 0;
            let previewAudio = null;
            let customWords = {};
            let playlist = [];
            let currentPlayingIds = [];
            let currentPlayingItemId = null; // Tracks the single item playing from the playlist
            let currentAudio = null; // ตัวแปรเก็บ audio ปัจจุบัน
            let chunksForDisplay = []; // เก็บ chunks สำหรับแสดงใน live text
            let isLocalProxyAvailable = true; // Assume local proxy is available by default
            let playAllQueue = []; // Queue for items to play when "Play All Unplayed" is active
            
            // Default prompts
            const defaultPrompts = {
                edit: `กรุณาช่วยจัดรูปแบบข้อความนิยายจีนให้เป็น style การเล่านิยายจีนเรื่อง \"กระบี่​จง​มา/​剑来/Jian Lai/SwordComing\" ดังนี้:                 
        1. แบ่งข้อความเป็นประโยคยืดหยุ่น (grammar-aware chunks) โดยไม่กำหนดจำนวนคำตายตัว
        2. ตรวจและแก้ไขคำผิด (grammar correction)
        3. แบ่งวรรค (punctuation-aware chunking) ให้ถูกต้อง
        4. จำกัดความยาว chunk ไม่เกิน 170 ตัวอักษร ตามความเหมาะสม
        5. แก้ไขปัญหาการตัดคำผิดพลาด และประโยคยาวเกินไป
        6. ป้องกันการตัดคำกลางประโยคที่ทำให้ความหมายเปลี่ยน
        7. ต้องลบสัญลักษณ์ เช่น ? \" ... ! * ( ) ฯลฯ อื่นๆ ที่จะทำให้ google translate อ่านผิด ตีความผิด โดยให้คงข้อความเดิมไว้
        8. รักษาภาษาต้นฉบับไว้ พร้อมทั้งเว้นวรรคให้เหมาะสมกับการอ่าน
        6. ให้เริ่มเรื่องเลย ไม่ต้องทวนคำถาม

        ข้อความที่ต้องประมวลผล:`,
                summarize: `กรุณาช่วยเรียบเรียงใหม่และเล่าแบบสรุปความของข้อความนิยายจีนเรื่อง \"กระบี่​จง​มา/​剑来/Jian Lai/SwordComing\" ให้ครบถ้วนและละเอียด โดย:
        1. สรุปเนื้อหาสำคัญทั้งหมดโดยละเอียด
        2. รักษาลำดับเหตุการณ์และความต่อเนื่อง
        3. ใช้ภาษาที่เข้าใจง่ายและเหมาะสมกับการอ่านออกเสียง
        4. แบ่งเป็นประโยคสั้นๆ ที่เหมาะสมกับการอ่าน
        5. รักษาความเป็นนิยายไว้
        6. ให้เริ่มเรื่องเลย ไม่ต้องทวนคำถาม

        ข้อความที่ต้องสรุป:`,
                mystyle: `กรุณาช่วยเรียบเรียงใหม่และเล่าแบบสรุปความของข้อความนิยายจีนเรื่อง \"กระบี่​จง​มา/​剑来/Jian Lai/SwordComing\" ให้ครบถ้วน โดย:
        1. สรุปเนื้อหาสำคัญทั้งหมดแบบสั้นๆ
        2. รักษาลำดับเหตุการณ์และความต่อเนื่อย (who what where how why)
        3. ใช้ภาษาที่เข้าใจง่ายและเหมาะสมกับการอ่านออกเสียง
        4. แบ่งเป็นประโยคสั้นๆ ที่เหมาะสมกับการอ่าน
        5. รักษาความเป็นนิยายไว้
        6. ให้เริ่มเรื่องเลย ไม่ต้องทวนคำถาม

        ข้อความที่ต้องประมวลผล:`
            };
            
            let prompts = {...defaultPrompts};
            
            // โหลด prompts จาก localStorage
            function loadPrompts() {
                try {
                    const saved = localStorage.getItem('aiPrompts');
                    if (saved) {
                        prompts = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Error loading prompts:', e);
                }
                updatePromptTextareas();
            }
            
            // บันทึก prompts ลง localStorage
            function savePrompts() {
                try {
                    prompts.edit = editPromptTextarea.value;
                    prompts.summarize = summarizePromptTextarea.value;
                    prompts.mystyle = mystylePromptTextarea.value;
                    localStorage.setItem('aiPrompts', JSON.stringify(prompts));
                    updateStatus('บันทึก Prompt เรียบร้อยแล้ว', 'success');
                } catch (e) {
                    updateStatus('เกิดข้อผิดพลาดในการบันทึก Prompt', 'error');
                }
            }
            
            // รีเซ็ต prompts เป็นค่า default
            function resetPrompts() {
                prompts = {...defaultPrompts};
                updatePromptTextareas();
                updateStatus('รีเซ็ต Prompt เป็นค่าเริ่มต้นแล้ว', 'success');
            }
            
            // อัปเดต textarea ด้วย prompts
            function updatePromptTextareas() {
                editPromptTextarea.value = prompts.edit;
                summarizePromptTextarea.value = prompts.summarize;
                mystylePromptTextarea.value = prompts.mystyle;
            }
            
            // ตรวจสอบ API Key
            function checkApiKey() {
                const apiKey = apiKeyInput.value.trim();
                if (apiKey) {
                    apiStatus.className = 'absolute right-3 top-1/2 transform -translate-y-1/2 w-3 h-3 rounded-full bg-green-500';
                    apiKeyInput.classList.add('valid-input');
                    apiKeyInput.classList.remove('invalid-input');
                } else {
                    apiStatus.className = 'absolute right-3 top-1/2 transform -translate-y-1/2 w-3 h-3 rounded-full bg-gray-500';
                    apiKeyInput.classList.remove('valid-input');
                    apiKeyInput.classList.remove('invalid-input');
                }
            }
            
            // โหลด API Key จาก localStorage
            function loadApiKey() {
                try {
                    const savedApiKey = localStorage.getItem('geminiApiKey');
                    if (savedApiKey) {
                        apiKeyInput.value = savedApiKey;
                        checkApiKey();
                    }
                } catch (e) {
                    console.error('Error loading API key:', e);
                }
            }
            
            // บันทึก API Key ลง localStorage
            function saveApiKey() {
                try {
                    const apiKey = apiKeyInput.value.trim();
                    if (apiKey) {
                        localStorage.setItem('geminiApiKey', apiKey);
                    } else {
                        localStorage.removeItem('geminiApiKey');
                    }
                } catch (e) {
                    console.error('Error saving API key:', e);
                }
            }
            
            // โหลด custom words จาก localStorage
            function loadCustomWords() {
                try {
                    const saved = localStorage.getItem('customWords');
                    if (saved) {
                        customWords = JSON.parse(saved);
                        updateCustomWordsTextarea();
                    }
                } catch (e) {
                    console.error('Error loading custom words:', e);
                }
            }
            
            // โหลด playlist จาก localStorage
            function loadPlaylist() {
                try {
                    const saved = localStorage.getItem('ttsPlaylist');
                    if (saved) {
                        playlist = JSON.parse(saved);
                    }
                } catch (e) {
                    console.error('Error loading playlist:', e);
                }
                updatePlaylistButton();
            }
            
            // บันทึก playlist ลง localStorage
            function savePlaylist() {
                try {
                    localStorage.setItem('ttsPlaylist', JSON.stringify(playlist));
                } catch (e) {
                    console.error('Error saving playlist:', e);
                }
                updatePlaylistButton();
            }
            
            // อัปเดตปุ่ม Playlist ให้แสดงจำนวนรายการ
            function updatePlaylistButton() {
                if (playlist.length > 0) {
                    playlistBtn.innerHTML = `<i data-feather="list"></i> Playlist [${playlist.length}]`;
                } else {
                    playlistBtn.innerHTML = `<i data-feather="list"></i> Playlist`;
                }
                feather.replace();
            }
            
            // อัปเดต textarea ด้วย custom words
            function updateCustomWordsTextarea() {
                let text = '';
                for (const [oldWord, newWord] of Object.entries(customWords)) {
                    text += `${oldWord};${newWord}\n`;
                }
                customWordsTextarea.value = text;
            }
            
            // บันทึก custom words ลง localStorage
            function saveCustomWords() {
                try {
                    const lines = customWordsTextarea.value.trim().split('\n');
                    customWords = {};
                    
                    for (const line of lines) {
                        if (line.trim()) {
                            const parts = line.split(';');
                            if (parts.length === 2) {
                                const oldWord = parts[0].trim();
                                const newWord = parts[1].trim();
                                if (oldWord && newWord) {
                                    customWords[oldWord] = newWord;
                                }
                            }
                        }
                    }
                    
                    localStorage.setItem('customWords', JSON.stringify(customWords));
                    updateStatus('บันทึกคำที่กำหนดเองเรียบร้อยแล้ว', 'success');
                } catch (e) {
                    updateStatus('เกิดข้อผิดพลาดในการบันทึก', 'error');
                }
            }
            
            // ฟังก์ชันเรียงลำดับคำ
            function sortCustomWords() {
                try {
                    const lines = customWordsTextarea.value.trim().split('\n');
                    const wordPairs = [];
                    
                    for (const line of lines) {
                        if (line.trim()) {
                            const parts = line.split(';');
                            if (parts.length === 2) {
                                const oldWord = parts[0].trim();
                                const newWord = parts[1].trim();
                                if (oldWord && newWord) {
                                    wordPairs.push({ old: oldWord, new: newWord });
                                }
                            }
                        }
                    }
                    
                    // เรียงลำดับตามคำเดิม
                    wordPairs.sort((a, b) => a.old.localeCompare(b.old));
                    
                    // สร้างข้อความใหม่
                    let sortedText = '';
                    wordPairs.forEach(pair => {
                        sortedText += `${pair.old};${pair.new}\n`;
                    });
                    
                    customWordsTextarea.value = sortedText;
                    updateStatus('เรียงลำดับคำเรียบร้อยแล้ว', 'success');
                } catch (e) {
                    updateStatus('เกิดข้อผิดพลาดในการเรียงลำดับ', 'error');
                }
            }
            
            // แทนที่คำตาม custom words - เวอร์ชันที่ปรับปรุงแล้ว
            function replaceCustomWords(text) {
                // จัดเรียงคำจากยาวไปสั้นเพื่อป้องกันการแทนที่ผิดพลาด
                const sortedWords = Object.entries(customWords)
                    .sort((a, b) => b[0].length - a[0].length);
                
                // ใช้ regex ที่ถูกต้องเพื่อแทนที่คำทั้งหมด
                let result = text;
                
                for (const [oldWord, newWord] of sortedWords) {
                    // สร้าง regex ที่ตรวจจับคำทั้งหมด (case-sensitive)
                    // โดยใช้ word boundaries (\b) สำหรับภาษาไทยจะใช้ \s หรือตัวอักษรจีน
                    const escapedOldWord = oldWord.replace(/[.*+?^${}()|[\\]/g, '\\$&');
                    const regex = new RegExp(escapedOldWord, 'g');
                    result = result.replace(regex, newWord);
                }
                
                return result;
            }
            
            function splitTextIntoChunks(text, maxLen) { // maxLen will be dynamic
                if (!text) return [];

                const chunks = [];
                let i = 0;
                while (i < text.length) {
                    let chunk;
                    if (i + maxLen >= text.length) {
                        chunk = text.substring(i);
                    } else {
                        let splitPos = i + maxLen;
                        let lastPunct = -1;
                        // Prioritize splitting at sentence-ending punctuation or newlines
                        ['.', '!', '?', 'ฯ', '…', '”', '\n'].forEach(p => {
                            const pos = text.lastIndexOf(p, splitPos);
                            if (pos > i && pos > lastPunct) {
                                lastPunct = pos;
                            }
                        });

                        if (lastPunct > i) {
                            splitPos = lastPunct;
                        } else {
                            // Otherwise, try to split at a space
                            const lastSpace = text.lastIndexOf(' ', splitPos);
                            if (lastSpace > i) {
                                splitPos = lastSpace;
                            }
                        }
                        chunk = text.substring(i, splitPos + 1);
                    }
                    const trimmedChunk = chunk.trim().replace(/[.!?ฯ…”]+$/, '');
                    if (trimmedChunk) {
                        chunks.push(trimmedChunk);
                    }
                    i += chunk.length;
                }
                return chunks;
            }

            // ฟังก์ชันสร้าง URL สำหรับ Google Translate TTS
            async function generateTTSUrl(chunk, index, total) {
                const currentSpeechSpeed = speechSpeed.value; // Get current speech speed
                if (isLocalProxyAvailable) {
                    try {
                        log(`Attempting to fetch chunk ${index + 1} from local proxy...`);
                        const response = await fetch('http://127.0.0.1:8000/api/proxy-tts', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ text: chunk, speed: currentSpeechSpeed }), // Pass speed to proxy
                            signal: AbortSignal.timeout(3000) // 3 second timeout
                        });
                        if (!response.ok) {
                            throw new Error(`Local proxy returned status ${response.status}`);
                        }
                        const blob = await response.blob();
                        log(`Chunk ${index + 1} fetched successfully from local proxy.`);
                        return URL.createObjectURL(blob);
                    } catch (error) {
                        log(`Local proxy failed for chunk ${index + 1}. Falling back to Google TTS.`, error);
                        isLocalProxyAvailable = false; // Mark proxy as unavailable
                        updateStatus('Local proxy ไม่พร้อมใช้งาน, กำลังใช้ Google TTS', 'warning');
                        setTimeout(() => { updateLiveText() }, 1000);
                        // Fall through to Google TTS
                    }
                }
                
                log(`Using Google TTS for chunk ${index + 1}.`);
                return `https://translate.google.com/translate_tts?ie=UTF-8&q=${encodeURIComponent(chunk)}&tl=th&client=tw-ob&ttsspeed=${currentSpeechSpeed}&total=${total}&idx=${index}`;
            }

            // ฟังก์ชันอัปเดตตัวเลขความคืบหน้า
            function updateProgressText() {
                const progressText = document.getElementById('progressText');
                if (audioQueue.length > 0) {
                    progressText.textContent = `${currentIndex + 1}/${audioQueue.length}`;
                } else {
                    progressText.textContent = '0/0';
                }
            }    

            // ฟังก์ชันอัปเดต progress bar
            function updateProgress() {
                if (audioQueue.length > 0) {
                    const progress = ((currentIndex) / audioQueue.length) * 100;
                    progressBar.style.width = `${progress}%`;
                    updateProgressText(); // เรียกฟังก์ชันใหม่
                }
            }
            
            // ฟังก์ชันอัปเดต live text display
            function updateLiveText() {
                if (chunksForDisplay.length > 0 && currentIndex < chunksForDisplay.length) {
                    statusDiv.textContent = chunksForDisplay[currentIndex];
                    statusDiv.className = 'text-center py-4 text-gray-300 status playing';
                } 
            }

            // --- New Buffering Logic ---
            async function fillAudioBuffer() {
                const PRELOAD_AHEAD = 3; // How many chunks to preload
                const MAX_RETRIES = 3;
                const RETRY_DELAY = 2000; // 2 seconds
                log(`fillAudioBuffer called. Current index: ${currentIndex}`);

                for (let i = 0; i < PRELOAD_AHEAD; i++) {
                    const lookaheadIndex = currentIndex + i;

                    if (lookaheadIndex >= audioQueue.length) continue; // End of queue
                    if (audioBuffer.has(lookaheadIndex)) continue; // Already buffered or fetching

                    audioBuffer.set(lookaheadIndex, 'fetching');
                    const chunkText = audioQueue[lookaheadIndex];

                    let success = false;
                    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
                        try {
                            log(`Fetching chunk ${lookaheadIndex + 1}, attempt ${attempt}...`);
                            const url = await generateTTSUrl(chunkText, lookaheadIndex, audioQueue.length);
                            if (url) {
                                const audio = new Audio(url);
                                audio.preload = 'auto';
                                audio.playbackRate = speechSpeed.value;
                                audioBuffer.set(lookaheadIndex, audio);
                                log(`Chunk ${lookaheadIndex + 1} is now buffered.`);
                                success = true;
                                break; // Exit retry loop on success
                            } else {
                                throw new Error('generateTTSUrl returned null');
                            }
                        } catch (error) {
                            log(`Attempt ${attempt} failed for chunk ${lookaheadIndex + 1}.`, error);
                            if (attempt < MAX_RETRIES) {
                                log(`Retrying in ${RETRY_DELAY / 1000} seconds...`);
                                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                            } else {
                                isPlaying = false;
                            }
                        }
                    }

                    if (!success) {
                        log(`All retry attempts failed for chunk ${lookaheadIndex + 1}.`);
                        audioBuffer.delete(lookaheadIndex); // Mark as failed
                    }
                }
            }
            
            async function playNext() {
                console.log(`[TTS Debug] playNext called. currentIndex: ${currentIndex}, audioQueue.length: ${audioQueue.length}, isPlaying: ${isPlaying}`);
                if (currentIndex >= audioQueue.length || !isPlaying) {
                    console.log(`[TTS Debug] playNext: Condition met for finishing playback. currentIndex: ${currentIndex}, audioQueue.length: ${audioQueue.length}, isPlaying: ${isPlaying}`);
                    if (!isPaused) finishPlayback();
                    return;
                }

                updateProgress();
                updateLiveText();

                fillAudioBuffer();

                let audio = audioBuffer.get(currentIndex);

                while (audio === 'fetching') {
                    log(`Waiting for chunk ${currentIndex + 1} to finish buffering...`);
                    await new Promise(resolve => setTimeout(resolve, 200));
                    audio = audioBuffer.get(currentIndex);
                }

                if (!audio || !(audio instanceof Audio)) {
                    log(`Error: Chunk ${currentIndex + 1} could not be loaded. Stopping playback.`);
                    updateStatus(`ไม่สามารถโหลดเสียงส่วนที่ ${currentIndex + 1} ได้`, 'error');
                    stopSpeech();
                    return;
                }
                
                currentAudio = audio;
                currentAudio.currentTime = 0; // Ensure fresh start for automatically played chunks
                log(`Playing chunk ${currentIndex + 1}/${audioQueue.length}.`);

                currentAudio.play().catch(error => {
                    log(`Error playing chunk ${currentIndex + 1}:`, error);
                    updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                    stopSpeech();
                });

                currentAudio.onended = function() {
                    log(`Finished playing chunk ${currentIndex + 1}.`);
                    
                    const playedAudio = audioBuffer.get(currentIndex);
                    if (playedAudio) {
                        const url = playedAudio.src;
                        if (url && url.startsWith('blob:')) {
                            URL.revokeObjectURL(url);
                            log(`Revoked blob URL for chunk ${currentIndex + 1}.`);
                        }
                        audioBuffer.delete(currentIndex);
                    }

                    if (isPlaying && !isPaused) {
                        currentIndex++;
                        playNext();
                    }
                };

                currentAudio.onerror = function(e) {
                    log(`Audio element error for chunk ${currentIndex + 1}:`, e);
                    updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                    stopSpeech();
                };
            }

            function showProgressThenChunk(index) {
                // Cancel previous timer if any
                if (window._chunkPreviewTimer) {
                    clearTimeout(window._chunkPreviewTimer);
                    window._chunkPreviewTimer = null;
                }

                // Show progress line immediately
                updateStatus(`กำลังอ่านออกเสียง... (${index + 1}/${audioQueue.length})`, 'playing');

                // After 0.5s show the actual chunk text (if available)
                window._chunkPreviewTimer = setTimeout(() => {
                    if (chunksForDisplay && chunksForDisplay[index]) {
                        statusDiv.textContent = chunksForDisplay[index];
                        statusDiv.className = 'text-center py-4 text-gray-300 status playing';
                    }
                    window._chunkPreviewTimer = null;
                }, 500);
            }    

            // ฟังก์ชันเล่น chunk ถัดไป
            async function playNextChunk() {
                if (currentIndex < audioQueue.length - 1) {
                    if (currentAudio) {
                        currentAudio.pause();
                    }
                    currentIndex++;

                    showProgressThenChunk(currentIndex);            

                    // ถ้ากำลังเล่นอยู่ ให้เล่น chunk ใหม่ทันที
                    if (isPlaying && !isPaused) {
                        playChunk(currentIndex);
                    } else {
                        // ถ้าหยุดชั่วคราว ให้อัปเดตสถานะและ progress bar เท่านั้น
                        updateProgress();
                        updateLiveText(); // อัปเดต live text
                        updateStatus(`หยุดชั่วคราวที่ chunk ${currentIndex + 1}/${audioQueue.length}`, 'success');
                    }
                    if (playlistModal.style.display === 'flex') {
                        renderPlaylist(); // Update button states in the modal
                    }
                }
            }
            
                        // ฟังก์ชันเล่น chunk ก่อนหน้า
                        async function playPreviousChunk() {
                            if (currentIndex > 0) {
                                if (currentAudio) {
                                    currentAudio.pause();
                                }
                                currentIndex--;
            
                                showProgressThenChunk(currentIndex);            
            
                                // ถ้ากำลังเล่นอยู่ ให้เล่น chunk ใหม่ทันที
                                if (isPlaying && !isPaused) {
                                    playChunk(currentIndex);
                                } else {
                                    // ถ้าหยุดชั่วคราว ให้อัปเดตสถานะและ progress bar เท่านั้น
                                    updateProgress();
                                    updateLiveText(); // อัปเดต live text
                                    updateStatus(`หยุดชั่วคราวที่ chunk ${currentIndex + 1}/${audioQueue.length}`, 'success');
                                }
                                if (playlistModal.style.display === 'flex') {
                                    renderPlaylist(); // Update button states in the modal
                                }
                            }
                        }            
            // ฟังก์ชันเล่น chunk ที่กำหนด
            function playChunk(index) {
                if (index >= audioQueue.length) return;

                currentIndex = index;
                updateProgress();
                updateLiveText(); // อัปเดต live text
                updateStatus(`กำลังอ่านออกเสียง... (${currentIndex + 1}/${audioQueue.length})`, 'playing');

                // เริ่มเติม buffer เพิ่ม
                fillAudioBuffer();

                // หยุด audio ปัจจุบันก่อน
                if (currentAudio) {
                    try {
                        currentAudio.pause();
                    } catch (e) { /* ignore */ }
                    currentAudio.onended = null;
                    currentAudio = null;
                }

                // ดึง audio จาก audioBuffer แทน preloadedChunks
                let audio = audioBuffer.get(currentIndex);

                // ถ้ากำลัง fetch ให้รอจนเสร็จ
                const waitForFetchAndPlay = async () => {
                    while (audioBuffer.get(currentIndex) === 'fetching') {
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                    audio = audioBuffer.get(currentIndex);
                    if (!audio || !(audio instanceof Audio)) {
                        // fallback: สร้าง audio ใหม่จาก URL (generateTTSUrl) แล้วเล่น
                        try {
                            const url = await generateTTSUrl(audioQueue[currentIndex], currentIndex, audioQueue.length);
                            if (!url) {
                                updateStatus(`ไม่สามารถโหลดเสียงส่วนที่ ${currentIndex + 1} ได้`, 'error');
                                return;
                            }
                            const a = new Audio(url);
                            a.preload = 'auto';
                            a.playbackRate = speechSpeed.value;
                            currentAudio = a;
                            a.play().catch(err => {
                                updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                                console.error(err);
                            });
                            attachAudioHandlers(a);
                        } catch (err) {
                            updateStatus('ไม่สามารถสร้างเสียงได้', 'error');
                            console.error(err);
                        }
                        return;
                    }

                    // เล่น audio ที่ได้จาก buffer
                    currentAudio = audio;
                    currentAudio.play().catch(error => {
                        updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                        console.error(error);
                    });
                    attachAudioHandlers(currentAudio);
                };

                // ถ้า audio ยังเป็นสถานะ fetching ให้รอ
                if (audio === 'fetching') {
                    waitForFetchAndPlay();
                    return;
                }

                // ถ้าไม่มี audio ใน buffer ให้สร้างและเล่น (fallback)
                if (!audio || !(audio instanceof Audio)) {
                    (async () => {
                        try {
                            const url = await generateTTSUrl(audioQueue[currentIndex], currentIndex, audioQueue.length);
                            if (!url) {
                                updateStatus(`ไม่สามารถโหลดเสียงส่วนที่ ${currentIndex + 1} ได้`, 'error');
                                return;
                            }
                            const a = new Audio(url);
                            a.preload = 'auto';
                            a.playbackRate = speechSpeed.value;
                            currentAudio = a;
                            await a.play();
                            attachAudioHandlers(a);
                        } catch (err) {
                            updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                            console.error(err);
                        }
                    })();
                    return;
                }

                // ถ้ามี audio พร้อมเล่นจาก buffer
                currentAudio = audio;
                currentAudio.currentTime = 0; // Reset playback position to start
                currentAudio.play().catch(error => {
                    updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                    console.error(error);
                });
                attachAudioHandlers(currentAudio);
            }

            // ช่วยแนบ handler ซ้ำๆ ให้ audio element
            function attachAudioHandlers(a) {
                a.onended = function() {
                    log(`Finished playing chunk ${currentIndex + 1}.`);
                    
                    const playedAudio = audioBuffer.get(currentIndex);
                    if (playedAudio) {
                        const url = playedAudio.src;
                        if (url && url.startsWith('blob:')) {
                            URL.revokeObjectURL(url);
                            log(`Revoked blob URL for chunk ${currentIndex + 1}.`);
                        }
                        audioBuffer.delete(currentIndex);
                    }

                    if (isPlaying && !isPaused) {
                        currentIndex++;
                        playNext();
                    }
                };

                a.onerror = function(e) {
                    log(`Audio element error for chunk ${currentIndex + 1}:`, e);
                    updateStatus('ไม่สามารถอ่านออกเสียงได้', 'error');
                    stopSpeech();
                };
            }

            // ฟังก์ชันสลับระหว่าง อ่านออกเสียง/หยุดชั่วคราว/เล่นต่อ
            function togglePlayPause() {
                if (!isPlaying && !isPaused) {
                    // เริ่มเล่น
                    const text = textInput.value.trim();
                    if (!text) {
                        updateStatus('กรุณาป้อนข้อความ', 'error');
                        return;
                    }
                    speakText();
                } else if (isPlaying && !isPaused) {
                    // หยุดชั่วคราว
                    isPaused = true;
                    isPlaying = false;
                    if (currentAudio) {
                        currentAudio.pause();
                    }
                    speakBtn.innerHTML = `<i data-feather="play"></i> อ่านต่อ`;
                    updateStatus('หยุดชั่วคราว', 'success');
                    feather.replace();
                } else if (!isPlaying && isPaused) {
                    // เล่นต่อ
                    isPlaying = true;
                    isPaused = false;
                    if (currentAudio) {
                        currentAudio.play();
                    }
                    speakBtn.innerHTML = `<i data-feather="pause"></i> กำลังอ่าน`;
                    // แสดงข้อความปัจจุบันทันทีเมื่อเล่นต่อ
                    if (chunksForDisplay && chunksForDisplay[currentIndex]) {
                        statusDiv.textContent = chunksForDisplay[currentIndex];
                        statusDiv.className = 'text-center py-4 text-gray-300 status playing';
                    }
                    feather.replace();
                }
            }
            
            // ฟังก์ชันจบการเล่น
            function finishPlayback() {
                log('Playback finished.');
                isPlaying = false;
                isPaused = false;
                updateStatus('อ่านเสร็จแล้ว', 'success');
                document.getElementById('progressText').textContent = `${audioQueue.length}/${audioQueue.length}`;
                progressBar.style.width = '100%';
                speakBtn.disabled = false;
                stopBtn.disabled = true;
                previousBtn.disabled = true;
                nextBtn.disabled = true;
                speakBtn.innerHTML = `<i data-feather="play"></i> อ่าน`;
                feather.replace();
                
                if (currentPlayingIds.length > 0) {
                    log(`Marking ${currentPlayingIds.length} playlist items as played.`);
                    currentPlayingIds.forEach(id => {
                        const item = playlist.find(item => item.id === id);
                        if (item) {
                            item.played = true;
                        }
                    });
                    savePlaylist();
                }
                

                
                // Clean up any remaining blob URLs from the buffer
                log('Cleaning up audio buffer...');
                for (const [index, audio] of audioBuffer.entries()) {
                    if (audio instanceof Audio && audio.src && audio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(audio.src);
                    }
                }
                audioBuffer.clear();

                currentPlayingIds = [];
                currentPlayingItemId = null;
                currentAudio = null;
                chunksForDisplay = [];
                audioQueue = [];
                
                if (playlistModal.style.display === 'flex') {
                    renderPlaylist();
                }

                // After all cleanup, if there are more items in playAllQueue, start playing the next one
                console.log(`[TTS Debug] finishPlayback: playAllQueue length before check: ${playAllQueue.length}`);
                if (playAllQueue.length > 0) {
                    const nextItemId = playAllQueue.shift(); // Get and remove the first item
                    const nextItem = playlist.find(item => item.id === nextItemId);
                    if (nextItem) {
                        console.log(`[TTS Debug] finishPlayback: Starting next item: ${nextItem.title}`);
                        speakText(nextItem.text, [nextItem.id], true); // Play the next item
                    } else {
                        console.error(`[TTS Debug] finishPlayback: Next item not found for ID: ${nextItemId}`);
                    }
                } else {
                    console.log(`[TTS Debug] finishPlayback: playAllQueue is empty. Sequential playback finished.`);
                }

                setTimeout(() => {
                    if (!isPlaying) {
                        progressBar.style.width = '0%';
                    }
                }, 20000);
            }
            
            // ฟังก์ชันแปลข้อความด้วย Google Translate
            async function translateText(text) {
                try {
                    const url = `https://translate.googleapis.com/translate_a/single?client=gtx&sl=th&tl=th&dt=t&q=${encodeURIComponent(text)}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    return data[0][0][0];
                } catch (error) {
                    console.error('Translation error:', error);
                    return text; // คืนค่าข้อความเดิมหากแปลไม่ได้
                }
            }
            
            // ฟังก์ชันอ่านออกเสียง
            async function speakText(textToSpeak = textInput.value, itemIds = [], isSequentialPlay = false) {
                console.log(`[TTS Debug] speakText called. isSequentialPlay: ${isSequentialPlay}`);
                const text = textToSpeak.trim();
                if (!text) {
                    console.warn('[TTS Debug] speakText failed: Text input is empty.');
                    return updateStatus('กรุณาป้อนข้อความ', 'error');
                }

                try {
                    if (!isSequentialPlay) { // Only stop speech if not part of a sequential play
                        console.log('[TTS Debug] speakText: Calling stopSpeech (not sequential play).');
                        stopSpeech(); // Clear previous state
                    } else {
                        console.log('[TTS Debug] speakText: Skipping stopSpeech (sequential play).');
                    }
                    updateStatus('กำลังประมวลผล...', 'playing');
                    console.log('[TTS Debug] speakText: Processing text...');

                    const chunks = splitTextIntoChunks(text, parseInt(chunkSize.value)); // Use dynamic chunkSize
                    if (!chunks.length) {
                        log('speakText failed: No chunks created from text.');
                        return updateStatus('ไม่มีข้อความให้อ่าน', 'error');
                    }
                    
                    const translatedChunks = await Promise.all(chunks.map(translateText));
                    const finalChunks = translatedChunks.map(replaceCustomWords);
                    log('Finished translating and replacing custom words.');

                    chunksForDisplay = finalChunks;
                    audioQueue = finalChunks; // Set the queue with TEXT chunks
                    
                    updateStatus(`พบ ${finalChunks.length} ส่วน กำลังเริ่มเล่น...`, 'playing');
                    log(`Split text into ${finalChunks.length} chunks.`);

                    // Set the currently playing item ID(s)
                    currentPlayingIds = itemIds || [];
                    if (currentPlayingIds.length === 1) {
                        currentPlayingItemId = currentPlayingIds[0];
                    } else {
                        currentPlayingItemId = null; // No single item is active during 'Play All'
                    }

                    isPlaying = true;
                    isPaused = false;
                    currentIndex = 0;
                    speakBtn.disabled = false;
                    stopBtn.disabled = false;
                    previousBtn.disabled = false;
                    nextBtn.disabled = false;
                    speakBtn.innerHTML = `<i data-feather="pause"></i> กำลังอ่าน`;
                    feather.replace();
                    
                    if (playlistModal.style.display === 'flex') {
                        renderPlaylist();
                    }

                    console.log('[TTS Debug] speakText: Kicking off playback and buffering...');
                    console.log(`[TTS Debug] speakText: Calling playNext. isPlaying: ${isPlaying}`);
                    fillAudioBuffer(); // Start filling the buffer
                    playNext(); // Start the playback loop

                } catch (error) {
                    log('speakText error:', error);
                    updateStatus('เกิดข้อผิดพลาด: ' + error.message, 'error');
                    stopSpeech();
                }
            }
            
            // ฟังก์ชันหยุดเสียง
            function stopSpeech() {
                console.log('[TTS Debug] stopSpeech called. Halting all playback and cleaning up.');
                isPlaying = false;
                isPaused = false;

                if (window._chunkPreviewTimer) {
                    clearTimeout(window._chunkPreviewTimer);
                    window._chunkPreviewTimer = null;
                }        
                
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio.onended = null; // Remove handler to prevent race conditions
                    currentAudio = null;
                }
                
                if (previewAudio) {
                    previewAudio.pause();
                    previewAudio = null;
                }
                
                // Clean up any blob URLs in the buffer
                for (const [index, audio] of audioBuffer.entries()) {
                    if (audio instanceof Audio && audio.src && audio.src.startsWith('blob:')) {
                        URL.revokeObjectURL(audio.src);
                    }
                }
                audioBuffer.clear();

                audioQueue = [];
                currentIndex = 0;
                chunksForDisplay = [];
                currentPlayingIds = [];
                currentPlayingItemId = null;
                playAllQueue = []; // Clear playAllQueue when stopping speech
                console.log('[TTS Debug] stopSpeech: playAllQueue cleared.');
                
                updateStatus('หยุดแล้ว', 'success');
                speakBtn.disabled = false;
                stopBtn.disabled = true;
                previousBtn.disabled = true;
                nextBtn.disabled = true;
                speakBtn.innerHTML = `<i data-feather="play"></i> อ่าน`;
                feather.replace();
                progressBar.style.width = '0%';

                if (playlistModal.style.display === 'flex') {
                    renderPlaylist();
                }

                setTimeout(() => {
                    if (!isPlaying) {
                        progressBar.style.width = '0%';
                    }
                }, 2000);

                // After all cleanup, if there are more items in playAllQueue, start playing the next one
                console.log(`[TTS Debug] finishPlayback: playAllQueue length before check: ${playAllQueue.length}`);
                if (playAllQueue.length > 0) {
                    const nextItemId = playAllQueue.shift(); // Get and remove the first item
                    const nextItem = playlist.find(item => item.id === nextItemId);
                    if (nextItem) {
                        console.log(`[TTS Debug] finishPlayback: Starting next item: ${nextItem.title}`);
                        speakText(nextItem.text, [nextItem.id], true); // Play the next item
                    } else {
                        console.error(`[TTS Debug] finishPlayback: Next item not found for ID: ${nextItemId}`);
                    }
                } else {
                    console.log(`[TTS Debug] finishPlayback: playAllQueue is empty. Sequential playback finished.`);
                }
            }
            
            // ฟังก์ชันล้างข้อความ
            async function clearText() {
                textInput.value = '';
                updateStatus('ป้อนข้อความเพื่อเริ่มต้น', '');
                updateProgressText();
            }
            
            // ฟังก์ชันวางข้อความจากคลิปบอร์ด
            async function pasteText() {
                try {
                    const text = await navigator.clipboard.readText();
                    textInput.value = text;
                    updateStatus('วางข้อความจากคลิปบอร์ดแล้ว', 'success');
                    updateProgressText();
                } catch (err) {
                    updateStatus('ไม่สามารถวางข้อความได้', 'error');
                }
            }

            let statusTimeout; // Declare a variable to hold the timeout ID

            // ฟังก์ชันอัปเดตสถานะ
            function updateStatus(message, type) {
                clearTimeout(statusTimeout); // Clear any previous timeout

                // แทนที่คำในข้อความก่อนการอัปเดตสถานะ
                message = replaceCustomWords(message);
                
                statusDiv.textContent = message;
                statusDiv.className = 'text-center py-4 text-gray-300 status ' + type;

                // If playing, revert to current chunk after 0.5 seconds
                if (isPlaying) {
                    statusTimeout = setTimeout(() => {
                        updateLiveText();
                    }, 500);
                }
            }

            // ฟังก์ชันทดสอบเสียง
            function previewSpeech() {
                const previewStatus = document.getElementById('previewStatus');
                const text = previewText.value.trim();

                if (!text) {
                    previewStatus.textContent = 'กรุณาป้อนข้อความ';
                    previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status error';
                    return;
                }
                
                try {
                    const customWordText = replaceCustomWords(text);
                    
                    translateText(customWordText).then(async (translated) => {
                        const finalText = replaceCustomWords(translated);
                        const url = await generateTTSUrl(finalText, 0, 1);

                        if (!url) {
                            previewStatus.textContent = 'ไม่สามารถสร้างเสียงตัวอย่างได้';
                            previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status error';
                            return;
                        }
                        
                        if (previewAudio) {
                            previewAudio.pause();
                        }
                        
                        previewAudio = new Audio(url);
                        previewAudio.playbackRate = speechSpeed.value;

                        // 1. Attach event handlers FIRST
                        previewAudio.onended = function() {
                            log('Preview audio finished.');
                            previewStatus.textContent = 'เล่นเสียงเสร็จแล้ว';
                            previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status success';
                            previewBtn.disabled = false;
                        };

                        previewAudio.onerror = function() {
                            log('Preview audio error.');
                            previewStatus.textContent = 'ไม่สามารถเล่นเสียงได้';
                            previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status error';
                            previewBtn.disabled = false;
                        };

                        // 2. THEN call play()
                        try {
                            await previewAudio.play();
                            log('Preview audio started.');
                            previewStatus.textContent = 'กำลังเล่นเสียง...';
                            previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status playing';
                            previewBtn.disabled = true;
                        } catch (error) {
                            log('previewAudio.play() was rejected.', error);
                            // The onerror handler will likely catch this, but just in case:
                            previewStatus.textContent = 'ไม่สามารถเล่นเสียงได้';
                            previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status error';
                            previewBtn.disabled = false;
                        }
                    });
                } catch (error) {
                    log('Error in previewSpeech:', error);
                    previewStatus.textContent = 'เกิดข้อผิดพลาด: ' + error.message;
                    previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status error';
                }
            }
            
            // นำเข้าจากไฟล์
            function importFromFile() {
                const file = importFileInput.files[0];
                if (!file) {
                    updateStatus('กรุณาเลือกไฟล์', 'error');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    customWordsTextarea.value = e.target.result;
                    updateStatus('นำเข้าข้อมูลจากไฟล์เรียบร้อย', 'success');
                };
                reader.readAsText(file, 'UTF-8');
            }
            
            // เพิ่มลง playlist
            function addToPlaylist() {
                const text = textInput.value.trim();
                
                if (!text) {
                    updateStatus('กรุณาป้อนข้อความ', 'error');
                    return;
                }
                
                // สร้างชื่อ playlist อัตโนมัติจากข้อความ
                let title = text.substring(0, 30);
                if (text.length > 30) {
                    title += '...';
                }
                
                playlist.push({
                    id: Date.now(),
                    title: title,
                    text: text,
                    createdAt: new Date().toLocaleString('th-TH'),
                    played: false
                });
                
                savePlaylist();
                updateStatus('เพิ่มลง Playlist แล้ว', 'success');
            }
            
            // ลบจาก playlist
            function removeFromPlaylist(id) {
                playlist = playlist.filter(item => item.id !== id);
                savePlaylist();
                renderPlaylist();
            }
            
            // ล้าง playlist ทั้งหมด
            function clearAllPlaylist() {
                playlist = [];
                savePlaylist();
                renderPlaylist();
                updateStatus('ล้าง Playlist ทั้งหมดเรียบร้อย', 'success');
            }
            
            // ทำเครื่องหมายว่ายังไม่ได้อ่าน
            function markAsUnread(id) {
                const item = playlist.find(item => item.id === id);
                if (item) {
                    item.played = false;
                    savePlaylist();
                    renderPlaylist();
                }
            }
            
            // เล่นจาก playlist
            function playFromPlaylist(id) {
                if (currentPlayingItemId === id) {
                    // If the clicked item is the one currently playing or paused
                    togglePlayPause(); // This will handle pause/resume
                } else {
                    // If a different item is clicked, stop current and play new one
                    stopSpeech(); // Stop any existing playback
                    const item = playlist.find(item => item.id === id);
                    if (item) {
                        speakText(item.text, [id]);
                    }
                }
            }
            
            // เล่นทั้งหมดที่ยังไม่ได้เล่น
            function playAllUnplayed() {
                const unplayedItems = playlist.filter(item => !item.played);
                if (unplayedItems.length === 0) {
                    updateStatus('ไม่มีรายการที่ยังไม่ได้เล่น', 'error');
                    return;
                }
                
                // Clear any existing playAllQueue
                playAllQueue = [];
                // Populate playAllQueue with IDs of unplayed items
                unplayedItems.forEach(item => playAllQueue.push(item.id));

                // Start playing the first item from the queue
                const firstItemId = playAllQueue.shift(); // Get and remove the first item
                const firstItem = playlist.find(item => item.id === firstItemId);
                if (firstItem) {
                    speakText(firstItem.text, [firstItem.id], true); // Pass true for isSequentialPlay
                }
            }
            
            // แสดง playlist
            function renderPlaylist() {
                if (playlist.length === 0) {
                    playlistItems.innerHTML = '<div class="text-center py-8 text-gray-400">ไม่มีรายการใน Playlist</div>';
                    playAllBtn.disabled = true;
                    clearAllBtn.disabled = true;
                    return;
                }

                const hasUnplayed = playlist.some(item => !item.played);
                playAllBtn.disabled = !hasUnplayed;
                clearAllBtn.disabled = false;

                playlistItems.innerHTML = '';
                // Temporary debug: Display currentIndex in statusDiv if modal is open
                // if (playlistModal.style.display === 'flex') {
                //     updateStatus(`Debug: currentIndex = ${currentIndex}, audioQueue.length = ${audioQueue.length}`, 'warning');
                // }

                playlist.forEach((item, index) => {
                    const playlistItem = document.createElement('div');
                    playlistItem.className = `playlist-item bg-gray-700 rounded-lg p-4 ${item.played ? 'played opacity-70' : ''}`;
                    
                    const isCurrentlyActive = (isPlaying || isPaused) && item.id === currentPlayingItemId;

                    let actionsHTML = '';
                    if (isCurrentlyActive) {
                        if (isPlaying) {
                            actionsHTML += `<button class="playlist-toggle-btn bg-red-600 hover:bg-red-700 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}"><i data-feather="pause"></i></button>`;
                        } else if (isPaused) {
                            actionsHTML += `<button class="playlist-toggle-btn bg-green-600 hover:bg-green-700 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}"><i data-feather="play"></i></button>`;
                        }
                        // Add chunk navigation buttons
                        actionsHTML += `<button class="playlist-chunk-prev-btn bg-gray-700 hover:bg-gray-600 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}" ${currentIndex <= 0 ? 'disabled' : ''}><i data-feather="skip-back"></i></button>`;
                        actionsHTML += `<button class="playlist-chunk-next-btn bg-gray-700 hover:bg-gray-600 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}" ${currentIndex >= audioQueue.length - 1 ? 'disabled' : ''}><i data-feather="skip-forward"></i></button>`;
                        actionsHTML += `<button class="playlist-cancel-btn bg-gray-600 hover:bg-gray-500 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}"><i data-feather="x-circle"></i></button>`;
                    } else {
                        actionsHTML += `<button class="playlist-toggle-btn bg-green-600 hover:bg-green-700 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}"><i data-feather="play"></i></button>`;
                    }

                    if (item.played) {
                        actionsHTML += `<button class="unread-btn bg-yellow-600 hover:bg-yellow-700 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}"><i data-feather="book-open"></i></button>`;
                    }
                    actionsHTML += `<button class="delete-btn bg-red-600 hover:bg-red-700 text-white py-1 px-3 rounded text-sm flex items-center gap-1" data-id="${item.id}"><i data-feather="trash-2"></i></button>`;

                    playlistItem.innerHTML = `
                        <div class="flex flex-col md:flex-row md:items-center gap-3">
                            <div class="flex items-center gap-3 flex-1">
                                <span class="font-bold text-primary-400">${index + 1}.</span>
                                <div class="flex-1">
                                    <div class="playlist-title font-medium ${item.played ? 'line-through' : ''}" title="${item.title}">${item.title}</div>
                                    <div class="text-xs text-gray-400 mt-1">${item.createdAt}</div>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-2">
                                ${actionsHTML}
                            </div>
                        </div>
                    `;
                    playlistItems.appendChild(playlistItem);
                });

                document.querySelectorAll('.playlist-toggle-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = parseInt(e.currentTarget.dataset.id); // Use currentTarget
                        playFromPlaylist(id);
                    });
                });

                document.querySelectorAll('.unread-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = parseInt(e.currentTarget.dataset.id); // Use currentTarget
                        markAsUnread(id);
                    });
                });

                document.querySelectorAll('.playlist-chunk-prev-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // These buttons don't need an ID from the button itself, they call global functions
                        playPreviousChunk();
                    });
                });

                document.querySelectorAll('.playlist-chunk-next-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // These buttons don't need an ID from the button itself, they call global functions
                        playNextChunk();
                    });
                });

                document.querySelectorAll('.playlist-cancel-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // This button doesn't need an ID from the button itself, it calls a global function
                        stopSpeech();
                    });
                });

                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const id = parseInt(e.currentTarget.dataset.id); // Use currentTarget
                        removeFromPlaylist(id);
                    });
                });
                feather.replace(); // Re-render icons after updating playlist
            }

            // โหลดรายการโมเดล
            async function loadModels() {
                const select = document.getElementById('modelSelect');
                select.innerHTML = '<option value="">กำลังโหลดโมเดล...</option>';
                select.disabled = true;

                try {
                    // ใช้ข้อมูลโมเดลคงที่ (ใน production ควรเรียก API จริง)
                    const models = [
                        'gemini-2.5-flash',
                        'gemini-2.0-flash',
                        'gemini-1.5-flash',
                        'gemini-1.5-pro',
                        'gemini-1.0-pro'
                    ];

                    select.innerHTML = '';
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model;
                        option.textContent = model;
                        if (model === 'gemini-2.5-flash') {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });
                } catch (error) {
                    // หากโหลดไม่สำเร็จ ใช้ค่าเริ่มต้น
                    select.innerHTML = `
                        <option value="gemini-2.5-flash" selected>gemini-2.5-flash</option>
                        <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                        <option value="gemini-1.5-flash">gemini-1.5-flash</option>
                        <option value="gemini-1.5-pro">gemini-1.5-pro</option>
                    `;
                    updateStatus('ไม่สามารถโหลดรายการโมเดลได้ ใช้ค่าเริ่มต้น', 'error');
                }

                select.disabled = false;
            }

            // Disable all AI buttons
            function disableAIButtons() {
                aiEditBtn.disabled = true;
                aiSummarizeBtn.disabled = true;
                aiMyStyleBtn.disabled = true;
                //promptBtn.disabled = true;
            }

            // Enable all AI buttons
            function enableAIButtons() {
                aiEditBtn.disabled = false;
                aiSummarizeBtn.disabled = false;
                aiMyStyleBtn.disabled = false;
                //promptBtn.disabled = false;
            }

            // ฟังก์ชันเล่นเสียงแจ้งเตือน
            function playNotificationSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }

            // AI Functions
            async function processWithAI() {
                const apiKey = apiKeyInput.value;
                const model = modelSelect.value;
                const text = textInput.value;
                
                if (!apiKey) {
                    updateStatus('กรุณาใส่ API Key', 'error');
                    return;
                }
                
                if (!text.trim()) {
                    updateStatus('ไม่มีข้อความให้ประมวลผล', 'error');
                    return;
                }
                
                // Disable all AI buttons and show processing status
                disableAIButtons();
                aiEditBtn.innerHTML = `<i data-feather="loader"></i> กำลังประมวลผล...`;
                updateStatus('AI กำลังประมวลผล...', 'playing');
                feather.replace();
                
                try {
                    const fullPrompt = prompts.edit + '\n' + text;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: fullPrompt
                                }]
                            }]
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.candidates[0].content.parts[0].text;
                    
                    textInput.value = aiResponse;
                    updateStatus('ประมวลผลด้วย AI สำเร็จ', 'success');
                    playNotificationSound(); // เล่นเสียงแจ้งเตือนเมื่อเสร็จสิ้น
                } catch (error) {
                    console.error('AI Processing error:', error);
                    updateStatus(`AI Processing error: ${error.message}`, 'error');
                } finally {
                    aiEditBtn.disabled = false;
                    aiEditBtn.innerHTML = `<i data-feather="edit"></i> AI จัดคำ`;
                    enableAIButtons();
                    feather.replace();
                }
            }

            async function summarizeWithAI() {
                const apiKey = apiKeyInput.value;
                const model = modelSelect.value;
                const text = textInput.value;
                
                if (!apiKey) {
                    updateStatus('กรุณาใส่ API Key', 'error');
                    return;
                }
                
                if (!text.trim()) {
                    updateStatus('ไม่มีข้อความให้ประมวลผล', 'error');
                    return;
                }
                
                // Disable all AI buttons and show processing status
                disableAIButtons();
                aiSummarizeBtn.innerHTML = `<i data-feather="loader"></i> กำลังสรุป...`;
                updateStatus('AI กำลังประมวลผล...', 'playing');
                feather.replace();
                
                try {
                    const fullPrompt = prompts.summarize + '\n' + text;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: fullPrompt
                                }]
                            }]
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.candidates[0].content.parts[0].text;
                    
                    textInput.value = aiResponse;
                    updateStatus('สรุปเนื้อหาด้วย AI สำเร็จ', 'success');
                    playNotificationSound(); // เล่นเสียงแจ้งเตือนเมื่อเสร็จสิ้น
                } catch (error) {
                    console.error('AI Summarize error:', error);
                    updateStatus(`AI Summarize error: ${error.message}`, 'error');
                } finally {
                    aiSummarizeBtn.disabled = false;
                    aiSummarizeBtn.innerHTML = `<i data-feather="file-text"></i> AI สรุป`;
                    enableAIButtons();
                    feather.replace();
                }
            }

            async function myStyleWithAI() {
                const apiKey = apiKeyInput.value;
                const model = modelSelect.value;
                const text = textInput.value;
                
                if (!apiKey) {
                    updateStatus('กรุณาใส่ API Key', 'error');
                    return;
                }
                
                if (!text.trim()) {
                    updateStatus('ไม่มีข้อความให้ประมวลผล', 'error');
                    return;
                }
                
                // Disable all AI buttons and show processing status
                disableAIButtons();
                aiMyStyleBtn.innerHTML = `<i data-feather="loader"></i> กำลังประมวลผล...`;
                updateStatus('AI กำลังประมวลผล...', 'playing');
                feather.replace();
                
                try {
                    const fullPrompt = prompts.mystyle + '\n' + text;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: fullPrompt
                                }]
                            }]
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                    }

                    const data = await response.json();
                    const aiResponse = data.candidates[0].content.parts[0].text;
                    
                    textInput.value = aiResponse;
                    updateStatus('ประมวลผลด้วย AI สั้น สำเร็จ', 'success');
                    playNotificationSound(); // เล่นเสียงแจ้งเตือนเมื่อเสร็จสิ้น
                } catch (error) {
                    console.error('AI My Style error:', error);
                    updateStatus(`AI My Style error: ${error.message}`, 'error');
                } finally {
                    aiMyStyleBtn.disabled = false;
                    aiMyStyleBtn.innerHTML = `<i data-feather="type"></i> สั้น`;
                    enableAIButtons();
                    feather.replace();
                }
            }

            // Event listeners
            speakBtn.addEventListener('click', togglePlayPause);
            stopBtn.addEventListener('click', stopSpeech);
            previousBtn.addEventListener('click', playPreviousChunk);
            nextBtn.addEventListener('click', playNextChunk);
            clearBtn.addEventListener('click', clearText);
            pasteBtn.addEventListener('click', pasteText);
            addToPlaylistMainBtn.addEventListener('click', addToPlaylist);

            wordBtn.addEventListener('click', function () {
                wordModal.classList.remove('hidden');
                wordModal.style.display = 'flex';
            });

            playlistBtn.addEventListener('click', function () {
                playlistModal.classList.remove('hidden');
                playlistModal.style.display = 'flex';
                renderPlaylist();
            });

            promptBtn.addEventListener('click', function () {
                promptModal.classList.remove('hidden');
                promptModal.style.display = 'flex';
            });

            // Settings modal event listeners
            settingBtn.addEventListener('click', () => {
                settingsModal.classList.remove('hidden');
                settingsModal.style.display = 'flex';
                loadSettings(); // Load settings when modal opens
            });

            closeSettingsModal.addEventListener('click', () => {
                settingsModal.style.display = 'none';
                settingsModal.classList.add('hidden');
            });

            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    settingsModal.style.display = 'none';
                    settingsModal.classList.add('hidden');
                }
            });

            closeWordModal.addEventListener('click', function () {
                wordModal.style.display = 'none';
                wordModal.classList.add('hidden');
            });

            closePlaylistModal.addEventListener('click', function () {
                playlistModal.style.display = 'none';
                playlistModal.classList.add('hidden');
            });

            closePromptModal.addEventListener('click', function () {
                promptModal.style.display = 'none';
                promptModal.classList.add('hidden');
            });

            window.addEventListener('click', function (event) {
                if (event.target === wordModal) {
                    wordModal.style.display = 'none';
                    wordModal.classList.add('hidden');
                }
                if (event.target === playlistModal) {
                    playlistModal.style.display = 'none';
                    playlistModal.classList.add('hidden');
                }
                if (event.target === promptModal) {
                    promptModal.style.display = 'none';
                    promptModal.classList.add('hidden');
                }
            });

            saveWordsBtn.addEventListener('click', saveCustomWords);
            importBtn.addEventListener('click', function() {
                importFileInput.click();
            });
            importFileInput.addEventListener('change', importFromFile);
            previewBtn.addEventListener('click', previewSpeech);
            playAllBtn.addEventListener('click', playAllUnplayed);
            clearAllBtn.addEventListener('click', clearAllPlaylist);
            sortWordsBtn.addEventListener('click', sortCustomWords);
            
            // AI Button Events
            aiEditBtn.addEventListener('click', processWithAI);
            aiSummarizeBtn.addEventListener('click', summarizeWithAI);
            aiMyStyleBtn.addEventListener('click', myStyleWithAI);
            savePromptsBtn.addEventListener('click', savePrompts);
            resetPromptsBtn.addEventListener('click', resetPrompts);

            // API Key Events
            apiKeyInput.addEventListener('input', checkApiKey);
            apiKeyInput.addEventListener('blur', saveApiKey);

            // Update status on text input change
            textInput.addEventListener('input', function () {
                if (textInput.value.trim()) {
                    updateStatus('พร้อมอ่านออกเสียง', 'success');
                } else {
                    updateStatus('ป้อนข้อความเพื่อเริ่มต้น', '');
                }
            });

            previewText.addEventListener('input', function () {
                if (previewText.value.trim()) {
                    previewStatus.textContent = 'พร้อมทดสอบเสียง';
                    previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status success';
                } else {
                    previewStatus.textContent = 'ป้อนข้อความเพื่อทดสอบ';
                    previewStatus.className = 'mt-3 text-center py-2 text-gray-300 status';
                }
            });

            // Initial load of settings (in case modal is not opened immediately)
            const loadSettings = () => {
                const savedSettings = JSON.parse(localStorage.getItem('readToSleepSettings'));
                if (savedSettings) {
                    speechSpeed.value = savedSettings.speechSpeed;
                    speechSpeedValue.textContent = `${savedSettings.speechSpeed}×`;
                    chunkSize.value = savedSettings.chunkSize;
                } else {
                    // Apply default settings if nothing is saved
                    speechSpeed.value = defaultSettings.speechSpeed;
                    speechSpeedValue.textContent = `${defaultSettings.speechSpeed}×`;
                    chunkSize.value = defaultSettings.chunkSize;
                }
            };

            // Default settings
            const defaultSettings = {
                speechSpeed: 1.35,
                chunkSize: 120
            };

            // Update speech speed value display and real-time playback rate
            speechSpeed.addEventListener('input', () => {
                speechSpeedValue.textContent = `${speechSpeed.value}×`;
                if (currentAudio) {
                    currentAudio.playbackRate = parseFloat(speechSpeed.value);
                }
            });

            // Save settings to localStorage
            saveSettingsBtn.addEventListener('click', () => {
                const settings = {
                    speechSpeed: parseFloat(speechSpeed.value),
                    chunkSize: parseInt(chunkSize.value)
                };
                localStorage.setItem('readToSleepSettings', JSON.stringify(settings));
                updateStatus('บันทึก Setting เรียบร้อยแล้ว', 'success');
                settingsModal.style.display = 'none';
                settingsModal.classList.add('hidden');
            });

            // Reset settings to default
            resetSettingsBtn.addEventListener('click', () => {
                speechSpeed.value = defaultSettings.speechSpeed;
                speechSpeedValue.textContent = `${defaultSettings.speechSpeed}×`;
                chunkSize.value = defaultSettings.chunkSize;
                localStorage.removeItem('readToSleepSettings'); // Clear saved settings
                updateStatus('ตั้งค่า Setting เป็นค่าเริ่มต้นแล้ว', 'success');
            });

            // โหลดข้อมูลเริ่มต้น
            loadCustomWords();
            loadPlaylist();
            loadPrompts();
            loadModels();
            loadApiKey();
            loadSettings(); // Call loadSettings here to apply initial settings
            updateStatus('ป้อนข้อความเพื่อเริ่มต้น', '');

        });
    </script>
    <script>
        feather.replace();
    </script>
</body>
</html>
